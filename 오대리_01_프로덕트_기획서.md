# 오대리 — 프로덕트 기획서 (개발 레퍼런스)

> **버전**: v1.0 | **작성일**: 2026-02-07
> **용도**: 바이브코딩 컨텍스트 — Claude/Cursor에 통째로 넣어서 사용
>
> "사진 3장이면 10분 만에 AI 상담원이 만들어져요"

---

## 목차

1. 프로젝트 요약
2. 기술 아키텍처
3. 데이터 모델 (SQL 스키마)
4. AI 파이프라인 & 프롬프트
5. 견적 엔진
6. 화면별 상세 스펙
7. 온보딩 UX
8. 알림톡 템플릿
9. 에러 & 예외 시나리오
10. 구독 결제 플로우
11. 주문 상태 흐름

---

## 1. 프로젝트 요약

### 한 줄 정의

**오대리** = 커스텀 주문 1인 가게의 AI 상담 + 견적 + 주문 관리 SaaS

### MVP 정의

"케이크 가게 1개가 실제로 주문 받을 수 있는 최소 제품"

### MVP 포함

- 고객 웹 채팅 UI
- AI 의도 분류 + 대화형 주문 상담
- AI 일반 CS 자동 응대
- 견적 자동 산출 (option_sum)
- 주문서 생성 + 사장님 알림
- 사장님 주문서 확인/수정/확정
- 고객 확정 알림톡 발송
- 사장님 대시보드 (주문 리스트)
- 사장님 온보딩 (가게정보/메뉴/FAQ)
- Type A 가게정보 관리
- Type B FAQ 관리
- 사장님 구독 결제 (토스페이먼츠)

### MVP 제외 (Phase 2+)

인스타 DM 연동, 캘린더 뷰, CRM, 고객→가게 결제, 다중 도메인 Config, 팀 플랜, 통계 대시보드, 샘플 디자인 선택, 자동 입금 확인, 연결제

---

## 2. 기술 아키텍처

### 전체 구조

```
[고객 터치포인트]
  웹 채팅 위젯 ← 사장님 인스타 프로필 링크
  카카오톡 채널 ← 솔라피 알림톡 API (알림 전용)

[프론트엔드]
  Next.js (Vercel) — 사장님 대시보드 + 고객 채팅 UI

[백엔드]
  Next.js API Routes (Vercel Serverless)
  Supabase Edge Functions (웹훅 수신)

[AI 엔진]
  의도 분류: Gemini 2.0 Flash Lite
  대화 생성: Gemini 2.0 Flash Lite
  견적 산출: 순수 서버 함수 (룰 기반, AI 아님)

[데이터]
  Supabase PostgreSQL — 가게정보, 메뉴, 주문
  Supabase pgvector — FAQ RAG
  Supabase Storage — 이미지
  Supabase Realtime — 실시간 알림

[외부 연동]
  솔라피 — 알림톡 8~10원/건
  토스페이먼츠 — 사장님 구독 정기결제 (빌링키)
  네이버/카카오 로컬 API — 가게 검색 자동채움
  국세청 API — 사업자 유효성 검증
```

### URL 구조

```
odaeri.com                          → 랜딩 (SSG)
odaeri.com/login                    → 가입/로그인
odaeri.com/dashboard                → 대시보드 홈
odaeri.com/dashboard/orders         → 주문 리스트
odaeri.com/dashboard/orders/{id}    → 주문 상세
odaeri.com/dashboard/settings       → 설정
odaeri.com/dashboard/subscription   → 구독/결제
odaeri.com/chat/{store_slug}        → 고객 채팅
odaeri.com/order/{order_id}         → 주문서 확인
odaeri.com/order/{order_id}/status  → 주문 상태
```

### AI 비용

```
가게 1개 / 월 120건 대화 (주문 40 + CS 80)
Gemini 2.0 Flash Lite: 입력 $0.075/1M, 출력 $0.30/1M
토큰: 입력 146,000 / 출력 21,200 토큰/월
비용: $0.017 ≈ 23원/월/가게
```

---

## 3. 데이터 모델

### ERD 관계

```
owners (사장님)
  └─ stores (가게) 1:1
       ├─ store_info (가게정보) 1:N
       ├─ menus (메뉴) 1:N
       │    └─ menu_options (옵션) 1:N
       ├─ order_rules (주문규칙) 1:1
       ├─ faq_embeddings (FAQ) 1:N
       ├─ consent_templates (동의서) 1:N
       ├─ notices (임시공지) 1:N
       ├─ conversations (대화) 1:N
       │    └─ messages (메시지) 1:N
       ├─ orders (주문) 1:N
       │    ├─ order_items (주문항목) 1:N
       │    ├─ order_consents (동의기록) 1:N
       │    └─ order_status_logs (상태이력) 1:N
       ├─ subscriptions (구독) 1:1
       └─ payments (결제내역) 1:N
```

### 전체 스키마 SQL

```sql
-- ==========================================
-- 1. 사장님 / 가게
-- ==========================================

CREATE TABLE owners (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  auth_id       UUID UNIQUE NOT NULL REFERENCES auth.users(id),
  name          TEXT NOT NULL,
  phone         TEXT NOT NULL,
  email         TEXT,
  created_at    TIMESTAMPTZ DEFAULT now(),
  updated_at    TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE stores (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id      UUID UNIQUE NOT NULL REFERENCES owners(id),
  name          TEXT NOT NULL,
  slug          TEXT UNIQUE NOT NULL,
  domain_type   TEXT NOT NULL DEFAULT 'cake',
  status        TEXT NOT NULL DEFAULT 'active',
    -- active / suspended / cancelled
  logo_url      TEXT,
  created_at    TIMESTAMPTZ DEFAULT now(),
  updated_at    TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_stores_slug ON stores(slug);

-- ==========================================
-- 2. 가게 정보 (Type A)
-- ==========================================

CREATE TABLE store_info (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id      UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  category      TEXT NOT NULL,
    -- address / parking / hours / payment / contact / location_detail
  data          JSONB NOT NULL,
  updated_at    TIMESTAMPTZ DEFAULT now()
);

CREATE UNIQUE INDEX idx_store_info_unique ON store_info(store_id, category);

-- data 예시:
-- hours: {"weekday":{"open":"10:00","close":"20:00"},"saturday":{"open":"10:00","close":"18:00"},"sunday":{"closed":true},"regular_holiday":"매주 월요일"}
-- parking: {"available":true,"detail":"매장 앞 2대, 30분 무료"}
-- payment: {"methods":["계좌이체","카카오페이"],"account":"국민 123-456-789 홍길동"}

-- ==========================================
-- 3. 메뉴 / 옵션
-- ==========================================

CREATE TABLE menus (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id         UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  name             TEXT NOT NULL,
  base_price       INTEGER NOT NULL,
  description      TEXT,
  image_url        TEXT,
  is_available     BOOLEAN DEFAULT true,
  sort_order       INTEGER DEFAULT 0,
  lettering_config JSONB,
    -- {"enabled":true,"free":true,"price":0,"max_chars":15}
  created_at       TIMESTAMPTZ DEFAULT now(),
  updated_at       TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_menus_store ON menus(store_id);

CREATE TABLE menu_options (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  menu_id          UUID NOT NULL REFERENCES menus(id) ON DELETE CASCADE,
  group_name       TEXT NOT NULL,
    -- size / topping / lettering / extra
  group_type       TEXT NOT NULL DEFAULT 'single',
    -- single (1개 선택) / multiple (복수 선택)
  name             TEXT NOT NULL,
  additional_price INTEGER NOT NULL DEFAULT 0,
  is_available     BOOLEAN DEFAULT true,
  sort_order       INTEGER DEFAULT 0
);

CREATE INDEX idx_menu_options_menu ON menu_options(menu_id);

CREATE TABLE order_rules (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id        UUID UNIQUE NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  min_order_days  INTEGER NOT NULL DEFAULT 3,
  same_day_order  BOOLEAN DEFAULT false,
  same_day_fee    INTEGER DEFAULT 0,
  pickup_start    TIME NOT NULL DEFAULT '11:00',
  pickup_end      TIME NOT NULL DEFAULT '18:00',
  updated_at      TIMESTAMPTZ DEFAULT now()
);

-- ==========================================
-- 4. FAQ / RAG (Type B)
-- ==========================================

CREATE TABLE faq_embeddings (
  id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id       UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  question       TEXT NOT NULL,
  answer         TEXT NOT NULL,
  embedding      VECTOR(768) NOT NULL,
  is_recommended BOOLEAN DEFAULT false,
  sort_order     INTEGER DEFAULT 0,
  created_at     TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_faq_store ON faq_embeddings(store_id);
CREATE INDEX idx_faq_embedding ON faq_embeddings USING ivfflat (embedding vector_cosine_ops);

-- ==========================================
-- 5. 동의서 / 공지
-- ==========================================

CREATE TABLE consent_templates (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id    UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  domain_type TEXT NOT NULL,
  title       TEXT NOT NULL,
  content     JSONB NOT NULL,
    -- {"sections":[{"title":"반려견 건강","type":"checkbox","options":["이상 없음","특이사항"]},
    --              {"title":"주의사항","type":"info","text":"..."},
    --              {"title":"보호자 정보","type":"input","fields":["이름","연락처","비상연락처"]}]}
  is_required BOOLEAN DEFAULT true,
  is_active   BOOLEAN DEFAULT true,
  created_at  TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE notices (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id    UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  title       TEXT NOT NULL,
  content     TEXT NOT NULL,
  start_date  DATE NOT NULL,
  end_date    DATE NOT NULL,
  is_active   BOOLEAN DEFAULT true,
  created_at  TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_notices_store_date ON notices(store_id, start_date, end_date);

-- ==========================================
-- 6. 대화 / 메시지
-- ==========================================

CREATE TABLE conversations (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id        UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  customer_id     TEXT,
  customer_name   TEXT,
  customer_phone  TEXT,
  state           TEXT NOT NULL DEFAULT 'idle',
    -- idle / ordering / collecting_menu / collecting_size /
    -- collecting_topping / collecting_lettering / collecting_pickup /
    -- collecting_request / order_ready / info / faq /
    -- waiting_owner / completed
  collected_data  JSONB DEFAULT '{}',
    -- 주문 진행 중 임시 저장: {"menu":"생크림","size":{"name":"2호","price":10000}}
  last_message_at TIMESTAMPTZ,
  created_at      TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_conv_store ON conversations(store_id);
CREATE INDEX idx_conv_customer ON conversations(customer_id);

CREATE TABLE messages (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  role            TEXT NOT NULL,   -- customer / ai / owner
  content         TEXT NOT NULL,
  message_type    TEXT DEFAULT 'text',
    -- text / image / order_card / quick_reply
  metadata        JSONB,
    -- image: {"url":"...","thumbnail_url":"..."}
    -- quick_reply: {"options":["미니","2호","3호"]}
    -- order_card: {"order_id":"..."}
  created_at      TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_messages_conv ON messages(conversation_id, created_at);

-- ==========================================
-- 7. 주문
-- ==========================================

CREATE TABLE orders (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id         UUID NOT NULL REFERENCES stores(id),
  conversation_id  UUID REFERENCES conversations(id),
  order_number     TEXT UNIQUE NOT NULL,  -- HC-20260214-001

  customer_name    TEXT,
  customer_phone   TEXT,

  status           TEXT NOT NULL DEFAULT 'pending',
    -- pending / confirmed / payment_waiting / paid /
    -- in_progress / completed / cancelled

  items_summary    TEXT,       -- "생크림 2호 + 딸기 + 레터링"
  calculated_price INTEGER NOT NULL,  -- AI 견적
  final_price      INTEGER,    -- 사장님 확정 (수정 가능)

  pickup_date      DATE,
  pickup_time      TIME,
  request_note     TEXT,
  owner_memo       TEXT,       -- 내부용

  image_urls       TEXT[],     -- 참고 이미지

  created_at       TIMESTAMPTZ DEFAULT now(),
  updated_at       TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_orders_store ON orders(store_id, created_at DESC);
CREATE INDEX idx_orders_status ON orders(store_id, status);

CREATE TABLE order_items (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id        UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  menu_name       TEXT NOT NULL,
  menu_base_price INTEGER NOT NULL,
  options         JSONB NOT NULL,
    -- [{"group":"size","name":"2호","price":10000},
    --  {"group":"topping","name":"딸기","price":5000}]
  subtotal        INTEGER NOT NULL,
  quantity        INTEGER DEFAULT 1
);

CREATE TABLE order_status_logs (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id    UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  from_status TEXT,
  to_status   TEXT NOT NULL,
  changed_by  TEXT NOT NULL,  -- system / owner / customer
  note        TEXT,
  created_at  TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE order_consents (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id      UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  template_id   UUID NOT NULL REFERENCES consent_templates(id),
  customer_name TEXT NOT NULL,
  consent_data  JSONB NOT NULL,
  agreed_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ==========================================
-- 8. 구독 / 결제
-- ==========================================

CREATE TABLE subscriptions (
  id                   UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id             UUID UNIQUE NOT NULL REFERENCES stores(id),
  plan                 TEXT NOT NULL DEFAULT 'trial',
    -- trial / pro / founding_free
  status               TEXT NOT NULL DEFAULT 'trial',
    -- trial / active / past_due / cancelled / suspended
  billing_key          TEXT,
  trial_ends_at        TIMESTAMPTZ,
  current_period_start TIMESTAMPTZ,
  current_period_end   TIMESTAMPTZ,
  cancelled_at         TIMESTAMPTZ,
  created_at           TIMESTAMPTZ DEFAULT now(),
  updated_at           TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE payments (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id         UUID NOT NULL REFERENCES stores(id),
  subscription_id  UUID NOT NULL REFERENCES subscriptions(id),
  amount           INTEGER NOT NULL,
  status           TEXT NOT NULL,  -- success / failed / refunded
  toss_payment_key TEXT,
  failed_reason    TEXT,
  paid_at          TIMESTAMPTZ,
  created_at       TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_payments_store ON payments(store_id, created_at DESC);

-- ==========================================
-- 9. 랜딩 / CRM
-- ==========================================

CREATE TABLE landing_hooks (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  text        TEXT NOT NULL,
  impressions INTEGER DEFAULT 0,
  conversions INTEGER DEFAULT 0,
  is_active   BOOLEAN DEFAULT true,
  created_at  TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE demo_leads (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_name        TEXT NOT NULL,
  phone             TEXT NOT NULL,
  marketing_consent BOOLEAN DEFAULT false,
  demo_count        INTEGER DEFAULT 0,
  last_demo_at      TIMESTAMPTZ,
  signed_up         BOOLEAN DEFAULT false,
  created_at        TIMESTAMPTZ DEFAULT now()
);

-- ==========================================
-- 10. 에러 로그
-- ==========================================

CREATE TABLE error_logs (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id   UUID REFERENCES stores(id),
  category   TEXT NOT NULL,  -- ai / order / payment / notification / system
  code       TEXT NOT NULL,
  message    TEXT,
  metadata   JSONB,
  resolved   BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- ==========================================
-- 11. RLS (Row Level Security)
-- ==========================================

ALTER TABLE stores ENABLE ROW LEVEL SECURITY;
ALTER TABLE store_info ENABLE ROW LEVEL SECURITY;
ALTER TABLE menus ENABLE ROW LEVEL SECURITY;
ALTER TABLE menu_options ENABLE ROW LEVEL SECURITY;
ALTER TABLE faq_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE payments ENABLE ROW LEVEL SECURITY;

-- 사장님: 자기 가게만
CREATE POLICY "owners_own_store" ON stores
  FOR ALL USING (owner_id = (SELECT id FROM owners WHERE auth_id = auth.uid()));

CREATE POLICY "owners_own_data" ON store_info
  FOR ALL USING (store_id IN (SELECT id FROM stores WHERE owner_id = (SELECT id FROM owners WHERE auth_id = auth.uid())));
-- menus, menu_options, orders, conversations, messages, subscriptions, payments 동일 패턴

-- 고객: 활성 가게 읽기
CREATE POLICY "customer_read_store" ON stores
  FOR SELECT USING (status = 'active');

CREATE POLICY "customer_read_menus" ON menus
  FOR SELECT USING (store_id IN (SELECT id FROM stores WHERE status = 'active') AND is_available = true);
```

---

## 4. AI 파이프라인 & 프롬프트

### 응답 파이프라인

```
고객 메시지
  ↓
[Layer 0] 임시공지 체크 (DB, AI 아님)
  ↓
[Layer 1] 의도 분류 (Gemini Flash Lite)
  → order / info / faq / chitchat / complex / image
  ↓
[Layer 2] 도메인별 대화 처리 (Gemini Flash Lite)
  ↓
[Layer 3] 응답 생성 + 톤 적용
```

### Layer 1: 의도 분류

```
시스템 프롬프트:

당신은 {store_name}의 고객 메시지 의도를 분류하는 분류기입니다.

다음 6가지 중 하나로 분류하세요:

- order: 주문, 가격, 견적, 예약 관련
  예: "케이크 주문하고 싶어요", "2호 얼마예요?", "토요일 픽업 가능?"

- info: 가게 기본정보 질문
  예: "주차 되나요?", "영업시간이 어떻게 되나요?", "위치가 어디예요?"

- faq: 자주 묻는 질문 / 정책 관련
  예: "보관은 어떻게 해요?", "알레르기 성분 있나요?", "취소 가능?"

- chitchat: 인사, 감사, 일상 대화
  예: "안녕하세요", "감사합니다", "ㅋㅋ"

- complex: AI가 판단하기 어려운 복잡한 요청
  예: "지난번에 주문한 거랑 똑같이", "특별 제작 상담 가능?"

- image: 이미지만 전송 (텍스트 없음)

반드시 JSON으로만 응답:
{"intent": "order", "confidence": 0.95}

대화 맥락:
{recent_messages}

고객 메시지:
{user_message}
```

토큰: 입력 ~130, 출력 ~10 / 건당 약 0.01원

### Layer 2a: 주문 대화 (Guided Chat)

```
시스템 프롬프트:

당신은 {store_name}의 AI 주문 상담원입니다.

## 역할
고객과 대화하며 주문에 필요한 정보를 하나씩 수집합니다.
모든 필수 옵션이 수집되면 견적을 계산하고 주문서를 생성합니다.

## 가게 메뉴 정보
{menus_json}

## 주문 규칙
- 최소 주문일: {min_order_days}일 전
- 당일 주문: {same_day_order}
- 픽업 가능 시간: {pickup_hours}
- 오늘 날짜: {today}

## 수집 순서
1. 메뉴 선택
2. 사이즈
3. 토핑/추가 옵션 (해당 시)
4. 레터링 문구 (해당 시)
5. 픽업 날짜 + 시간
6. 요청사항 (선택)

## 응답 규칙
- 한 번에 한 가지만 질문
- 옵션이 있으면 선택지를 보여주기
- 가격은 항상 함께 안내
- 고객이 애매하게 말하면 확인 질문
- 주문 규칙에 어긋나면 부드럽게 안내
  예: "최소 3일 전 주문이라 2/14 이후 픽업이 가능해요!"
- 아래 메뉴 외의 메뉴는 절대 언급하지 마세요
- 모든 정보 수집 완료 시 대화 응답 후 마지막 줄에:

###ORDER_READY###
{
  "menu": "생크림 케이크",
  "options": {
    "size": {"name": "2호", "price": 10000},
    "toppings": [{"name": "딸기", "price": 5000}],
    "lettering": {"text": "생일축하해", "price": 0},
    "extras": [{"name": "초 세트", "price": 2000}]
  },
  "pickup_date": "2026-02-14",
  "pickup_time": "14:00",
  "request": "초코 플레이트로 부탁드려요",
  "images": ["img_001.jpg"]
}

## 톤
{tone_setting}

## 현재 수집 상태
{collected_so_far}

## 대화 내역
{conversation_history}
```

토큰: 입력 ~500~800, 출력 ~100~200 / 주문 1건 평균 4턴

### Layer 2b: 가게정보 응답 (Type A)

```
시스템 프롬프트:

당신은 {store_name}의 AI 상담원입니다.
고객이 가게 정보를 물어봤습니다. 아래 정보를 바탕으로 친절하게 답변하세요.

## 가게 정보
주소: {address}
상세 위치: {location_detail}
영업시간: {hours}
휴무일: {closed_days}
주차: {parking}
결제 방식: {payment_methods}
연락처: {contact}

## 규칙
- 질문에 해당하는 정보만 답변
- 없는 정보는 "사장님께 확인해볼게요!"
- 자연스럽고 간결하게

## 톤
{tone_setting}

고객 질문:
{user_message}
```

### Layer 2c: FAQ 응답 (Type B, RAG)

```
처리 순서:
1. 고객 메시지 → 임베딩 생성
2. faq_embeddings 테이블에서 유사도 검색 (top 3)
3. 유사도 ≥ 0.7 → 답변 생성 / < 0.7 → 사장님 전달

시스템 프롬프트:

당신은 {store_name}의 AI 상담원입니다.
고객 질문에 대해 아래 FAQ를 참고하여 답변하세요.

## 관련 FAQ
Q: {faq_1_question}
A: {faq_1_answer}
(유사도: {score_1})

Q: {faq_2_question}
A: {faq_2_answer}
(유사도: {score_2})

## 규칙
- FAQ 내용을 자연스럽게 변환하여 답변
- FAQ에 없는 내용은 추측하지 말고 사장님 전달
- "사장님께 확인해서 알려드릴게요!"

## 톤
{tone_setting}

고객 질문:
{user_message}
```

### Layer 2d: 일상 대화 (Chitchat)

```
규칙:
- 1~2문장으로 짧게
- 자연스럽게 주문/문의로 유도
- 예: "안녕하세요! 😊 케이크 주문이나 궁금한 점 있으시면 편하게 말씀해주세요!"
- 3회 이상 chitchat 연속이면 적극 유도
```

### Layer 2e: 복잡한 요청 (Complex → 사장님 전달)

```
1. 고객: "이 부분은 사장님께 직접 확인해드릴게요! 빠르게 답변 드리겠습니다 😊"
2. 사장님 알림: Realtime + 알림톡 (T2)
3. conversation.state = 'waiting_owner'
```

### Layer 2f: 이미지 처리

```
- 주문 중: "참고 사진 잘 받았어요! 주문서에 첨부할게요 📷"
- 주문 전: "예쁜 디자인이네요! 이런 스타일로 주문하시려는 건가요?" → order 전환
- 메뉴판 이미지: "메뉴와 가격은 제가 안내해드릴게요!" → 메뉴 안내
```

### 톤 프리셋

```
[친근하고 다정하게] (기본값)
"반말은 사용하지 않습니다. 이모지를 적절히 사용합니다 (문장당 최대 1개).
'~요', '~세요' 체로 부드럽게. 감탄사 자연스럽게: '오!', '좋아요!', '네네!'
고객 이름을 알면 '○○님'으로 호칭."

[깔끔하고 전문적으로]
"반말X. 이모지X. '~입니다', '~습니다' 체. 간결하고 명확하게."

[직접 작성]
사장님 자유 텍스트 → 시스템 프롬프트에 그대로 삽입
```

### 대화 상태 관리

```
conversation.state 값:
  idle → ordering → collecting_* → order_ready → completed
  idle → info / faq (답변 후 idle 복귀)
  idle → waiting_owner (사장님 답변 대기)

전환 규칙:
- ordering 중 info/faq 질문 → 답변 후 ordering 복귀
- ordering 중 30분 미활동 → 리마인드 "이어서 하시겠어요?"
- 24시간 미활동 → 세션 종료 (collected_data 보존, 재방문 시 복구)
- 7일 후 collected_data 삭제
```

---

## 5. 견적 엔진

### MVP 방식: option_sum

```
공식: total = base_price + Σ(option.price) + (당일추가금)
```

### 계산 함수

```javascript
function calculatePrice(menu, selectedOptions, orderRules, isSameDay) {
  let total = menu.base_price;
  const breakdown = [];

  breakdown.push({ item: menu.name, price: menu.base_price, type: 'base' });

  for (const option of selectedOptions) {
    total += option.price;
    breakdown.push({
      item: `${option.group}: ${option.name}`,
      price: option.price,
      type: 'option'
    });
  }

  if (menu.lettering_config?.enabled && !menu.lettering_config.free) {
    total += menu.lettering_config.price;
    breakdown.push({ item: '레터링', price: menu.lettering_config.price, type: 'option' });
  }

  if (isSameDay && orderRules.same_day_order && orderRules.same_day_fee > 0) {
    total += orderRules.same_day_fee;
    breakdown.push({ item: '당일 주문 추가금', price: orderRules.same_day_fee, type: 'surcharge' });
  }

  return { total, breakdown };
}
```

### 유효성 검증

```javascript
function validateOrder(menu, options, pickupDate, pickupTime, orderRules) {
  const errors = [];

  // 메뉴 판매중 확인
  if (!menu?.is_available)
    errors.push({ code: 'MENU_UNAVAILABLE', message: '현재 판매 중이 아닌 메뉴예요' });

  // 필수 옵션 그룹 체크 (size 등)
  for (const group of getRequiredGroups(menu)) {
    if (!options.find(o => o.group === group))
      errors.push({ code: 'MISSING_OPTION', message: `${groupLabel(group)}을(를) 선택해주세요`, group });
  }

  // 옵션 DB 존재 여부
  for (const option of options) {
    const valid = menuOptions.find(o => o.group_name === option.group && o.name === option.name);
    if (!valid) errors.push({ code: 'INVALID_OPTION', message: `"${option.name}" 옵션이 없어요` });
    if (valid && !valid.is_available) errors.push({ code: 'OPTION_UNAVAILABLE', message: `"${option.name}" 현재 선택 불가` });
  }

  // 레터링 글자수
  if (options.lettering?.text) {
    const max = menu.lettering_config?.max_chars || 15;
    if (options.lettering.text.length > max)
      errors.push({ code: 'LETTERING_TOO_LONG', message: `레터링은 ${max}자까지 가능해요 (현재 ${options.lettering.text.length}자)` });
  }

  // 픽업일
  if (pickupDate) {
    const daysUntil = diffDays(today, pickupDate);
    if (daysUntil < 0) errors.push({ code: 'PAST_DATE', message: '지난 날짜 선택 불가' });
    if (daysUntil === 0 && !orderRules.same_day_order) errors.push({ code: 'NO_SAME_DAY', message: `최소 ${orderRules.min_order_days}일 전 주문 필요` });
    if (daysUntil > 0 && daysUntil < orderRules.min_order_days) errors.push({ code: 'TOO_SOON', message: `${suggestDate(orderRules.min_order_days)} 이후 픽업 가능` });
  }

  // 픽업 시간
  if (pickupTime && (pickupTime < orderRules.pickup_start || pickupTime > orderRules.pickup_end))
    errors.push({ code: 'INVALID_TIME', message: `픽업은 ${orderRules.pickup_start}~${orderRules.pickup_end} 사이` });

  return { valid: errors.length === 0, errors };
}
```

### 검증 실패 시 AI 응답

```
MENU_UNAVAILABLE → "아쉽게도 {메뉴}는 현재 품절이에요 😢 {다른 메뉴}는 어떠세요?"
MISSING_OPTION   → "{그룹}을 선택해주세요! [옵션 버튼]"
INVALID_OPTION   → "'{옵션명}'은 없는 옵션이에요. 선택 가능: {리스트}"
LETTERING_TOO_LONG → "레터링은 {max}자까지 가능해요! 줄여주시겠어요?"
NO_SAME_DAY/TOO_SOON → "{suggestDate} 이후 픽업이 가능해요!"
INVALID_TIME     → "픽업은 {start}~{end} 사이에 가능해요!"
```

### Phase 2 견적 확장

| 방식 | 공식 | 대상 |
|------|------|------|
| option_sum | base + Σ(opt) | 케이크, 디저트, 떡케이크, 캔들 |
| option_sum×qty | (base + Σ(opt)) × qty | 케이크토퍼, 캘리그라피 |
| option_sum+char | base_per_char × chars + Σ(opt) | 네온사인, 자수 |
| tier_based | tier.price + Σ(opt) | 꽃, 풍선 |
| area_based | base_per_unit × units + Σ(opt) | 네일아트 |

---

## 6. 화면별 상세 스펙

### 고객용 (3개)

#### C1. 채팅 메인 (`/chat/{store_slug}`)

- **헤더**: 가게 프로필 + 이름 + "AI 상담원이 24시간 응대합니다 🤖" + 영업 뱃지 (🟢/🔴)
- **초기 화면**: `🤖 "안녕하세요! {가게명}입니다 😊 무엇을 도와드릴까요?"` + 퀵버튼 [🎂 주문] [ℹ️ 가게정보] [💬 문의]
- **메시지 타입**: 텍스트, 이미지, 주문서 카드, 옵션 선택 버튼
- **옵션 선택 UI**: AI 질문 + 버튼 (예: [미니 +0원] [2호 +10,000원] [3호 +20,000원]) → 탭=전송+다음질문
- **이미지 전송**: 📷 버튼 → 카메라/갤러리 → 주문서에 첨부
- **주문서 카드**: 옵션 요약 + 견적 + [주문 확정하기]
- **입력바**: [📷] [메시지 입력...] [전송]
- **세션**: 브라우저 닫아도 URL 재접속, 24시간 만료, 재방문 시 이전 내역 표시
- **에러**: 네트워크 → 재시도 안내 / AI 실패 → 사장님 전달 / 서비스 정지 → 이용불가

#### C2. 주문서 확인 (`/order/{order_id}`)

- 주문 요약 (메뉴, 옵션별 가격 내역, 합계)
- 픽업 일시/장소, 참고 이미지 썸네일, 요청사항
- **동의서** (도메인별, 필요 시) — 체크박스 + 서명
- 고객 이름/연락처 입력 (알림톡 수신용)
- [주문 확정] [수정 요청 → 채팅으로 돌아감]
- 확정 후: "✅ 주문 접수! 사장님 확인 후 알림톡으로 안내드려요"

#### C3. 주문 상태 (`/order/{order_id}/status`)

- 상태 타임라인: ● 접수 → ● 확인 → ● 입금대기 → ○ 입금확인 → ○ 제작 → ○ 완료
- 현재 상태 강조 (입금대기 시: 계좌 + [복사] 버튼)
- [채팅으로 돌아가기]

### 사장님용 (10개)

#### S1. 로그인/가입 (`/login`)

- [카카오로 시작하기] (메인) + [이메일로 가입] (서브)
- 추가 정보: 사장님 이름, 가게 이름, 전화번호, 업종 [케이크 ▾] (나머지 "준비 중")
- 약관: ☑이용약관(필수) ☑개인정보(필수) ☐마케팅(선택)
- [14일 무료 체험 시작하기]

#### S2. 온보딩 Step 1 — 가게 찾기

- 가게명 검색 → 네이버/카카오 로컬 API → 결과 리스트 → [이 가게에요]
- 자동 채움: 주소, 영업시간, 전화번호
- 추가 입력: 상세 위치, 주차(가능/불가/공영), 결제 방식 + 입금 계좌
- [검색 결과에 없어요 → 직접 입력]

#### S3. 온보딩 Step 2 — 메뉴 등록

- [📷 메뉴판 사진] / [📋 텍스트 붙여넣기] / [✏️ 직접 입력]
- Gemini Vision → 구조화된 메뉴 초안 → 사장님 확인/수정
- 각 메뉴: 이름, 기본가, 사이즈 옵션, 토핑, 레터링, 추가 옵션 (테이블 형태)
- AI 확인 못한 항목: ⚠️ 표시 + 가격 직접 입력
- 주문 규칙: 최소 주문일, 당일 주문, 픽업 시간

#### S4. 온보딩 Step 3 — FAQ

- [📷 카톡/DM 캡처] / [📋 텍스트 붙여넣기] / [⏭️ 추천 FAQ만]
- AI 추출 FAQ + 업종별 추천 FAQ → 체크/수정
- 응대 톤: ◉친근 ○깔끔 ○직접작성
- 모르는 질문 정책: ◉사장님 전달 ○카톡 유도

#### S5. 온보딩 Step 4 — 테스트

- 채팅 링크 생성: `odaeri.com/chat/{slug}` + [링크 복사] [QR 다운로드]
- 임베디드 채팅으로 실시간 테스트 (견적 확인)
- 인스타 프로필 문구 제공 + [문구 복사]
- [대시보드로 가기]

#### S6. 대시보드 홈 (`/dashboard`)

- 요약 카드: [오늘 주문 3건] [미확인 1건 🔴] [이번 달 47건]
- 알림 배너: 미확인 주문 / 체험 만료
- 최근 주문 5건 + [전체 보기]
- AI 상담 현황: 오늘 대화 / 자동처리율
- 하단 네비: [홈] [주문] [설정] [구독]

#### S7. 주문 리스트 (`/dashboard/orders`)

- 필터 탭: [전체] [미확인🔴] [입금대기] [제작중] [완료]
- 검색: 고객명/주문번호
- 날짜: [오늘] [이번주] [이번달] [날짜선택]
- 주문 카드: 번호, 상태, 고객명, 메뉴 요약, 금액, 픽업일시

#### S8. 주문 상세 (`/dashboard/orders/{id}`)

- 주문 정보 + 상태 드롭다운 변경
- 고객 정보, 주문 내역 (금액 수정 가능), 픽업, 요청, 참고 이미지
- 동의서 확인 (있는 경우) [보기]
- AI 대화 열람 [대화 내용 보기 ▾]
- 액션: [주문 확정] [금액 수정 후 확정] [입금 확인] [제작 완료] [주문 거절(사유)]
- 사장님 메모 (내부용)

#### S9. 설정 (`/dashboard/settings`)

- **탭**: 가게정보 / 메뉴관리 / FAQ관리 / 임시공지 / 계정
- 가게정보: S2와 동일 필드
- 메뉴관리: S3와 동일 + 메뉴별 🟢판매중/🔴품절 토글
- FAQ관리: S4와 동일 + Q&A 추가/수정/삭제
- 임시공지: 제목/내용/기간/활성 토글 (AI가 대화 시작 시 먼저 안내)
- 계정: 이메일, 알림 설정, 탈퇴

#### S10. 구독/결제 (`/dashboard/subscription`)

- 현재 플랜: 체험(남은일수) or Pro(다음결제일, 결제수단)
- [Pro 구독하기] / [결제 수단 변경] [구독 해지]
- 결제 내역 리스트
- 해지: "다음 결제일부터 중단, 데이터 30일 보관" + [해지하기]

---

## 7. 온보딩 UX

### 전체 구조

```
가입(2분) → 가게찾기(2분) → 메뉴(4분) → FAQ(2분) → 테스트(3분) = 약 10분
핵심: "사진 3장이면 10분 만에 AI 상담원이 만들어져요"
```

### AI 자동화

| 단계 | 기존 | AI 후 | 방법 |
|------|------|-------|------|
| 가게정보 | 5분 | 2분 | 네이버/카카오 로컬 API 자동채움 |
| 메뉴 | 10분 | 4분 | Gemini Vision 메뉴판 인식 |
| FAQ | 5분 | 2분 | Gemini Vision 카톡 캡처 추출 + 추천 FAQ |

온보딩 AI 비용: 가게당 100~200원 (1회성)

---

## 8. 알림톡 템플릿

### 전체 목록 (14개)

| ID | 대상 | 제목 | 발송 시점 |
|----|------|------|-----------|
| T1 | 사장님 | 새 주문 알림 | 주문서 생성 즉시 |
| T2 | 사장님 | 복잡한 문의 전달 | AI→complex |
| T3 | 사장님 | 체험 만료 D-7 | trial_ends_at - 7일 |
| T4 | 사장님 | 체험 만료 D-2 | trial_ends_at - 2일 |
| T12 | 사장님 | 체험 만료 D-Day | trial_ends_at 당일 |
| T14 | 사장님 | 첫 구독 환영 | 체험→유료 첫 전환 |
| T13 | 사장님 | 결제 완료 (매월) | 결제 성공 시 |
| T10 | 사장님 | 결제 실패 | 자동결제 실패 |
| T11 | 사장님 | 서비스 정지 | Grace 종료 |
| T5 | 고객 | 주문 확정 + 입금 안내 | 사장님 [확정] |
| T6 | 고객 | 금액 수정 확정 | 사장님 금액 수정 |
| T7 | 고객 | 입금 확인 + 제작 시작 | 사장님 [입금확인] |
| T8 | 고객 | 제작 완료 + 픽업 안내 | 사장님 [제작완료] |
| T9 | 고객 | 주문 거절 | 사장님 [거절] |

### 템플릿 상세 (주요 5개)

**T1. 새 주문 (사장님)**
```
[#{orderNumber} 새 주문이 들어왔어요]
{storeName}에 새 주문이 접수되었습니다.
■ 주문 내용: {itemsSummary}
■ 금액: {calculatedPrice}원
■ 픽업: {pickupDate} {pickupTime}
지금 확인하고 주문을 확정해주세요!
▶ 주문 확인하기
```

**T5. 주문 확정 + 입금 (고객)**
```
[{storeName} 주문이 확정되었어요]
주문번호: #{orderNumber}
■ 주문 내용: {itemsSummary}
■ 확정 금액: {finalPrice}원
■ 픽업: {pickupDate} {pickupTime}
■ 입금: {bankAccount} / {finalPrice}원
입금 확인 후 제작이 시작됩니다!
▶ 주문 상태 확인
```

**T7. 입금 확인 (고객)**
```
[{storeName} 입금이 확인되었어요]
주문번호: #{orderNumber}
입금이 확인되어 제작을 시작합니다!
■ 픽업: {pickupDate} {pickupTime}
■ 장소: {storeAddress}
▶ 주문 상태 확인
```

**T13. 결제 완료 (사장님, 매월)**
```
[오대리 구독 결제 완료]
{ownerName} 사장님, 이번 달 구독 결제가 완료되었습니다.
■ 금액: 29,900원
■ 결제일: {paidDate}
■ 결제 수단: {cardInfo}
■ 다음 결제일: {nextPaymentDate}
▶ 결제 내역 확인
```

**T10. 결제 실패 (사장님)**
```
[오대리 구독 결제 안내]
{ownerName} 사장님, 이번 달 구독 결제가 실패했습니다.
■ 금액: 29,900원 / 사유: {failedReason}
3일 내 결제 수단을 확인해주세요. 미결제 시 서비스가 일시 중단됩니다.
▶ 결제 수단 확인하기
```

(나머지 T2, T3, T4, T6, T8, T9, T11, T12, T14는 비즈니스 문서 참조)

### 운영

- 심사 제출: 개발 Week 8 (3~5영업일)
- 비용: 건당 8~10원
- 실패: 3회 재시도 → 로그 + 수동 재발송 버튼

---

## 9. 에러 & 예외 시나리오

### AI 관련

| 코드 | 상황 | 처리 |
|------|------|------|
| A1 | API 실패 (타임아웃/에러) | 1회 재시도(2초) → "다시 말씀해주세요" → 3차 사장님 전달 |
| A2 | 의도 confidence < 0.6 | 퀵버튼 [주문] [가게정보] [문의] 재분류 유도 |
| A3 | 환각 (없는 메뉴) | 서버에서 DB 대조 → 불일치 시 재생성 1회 → 리셋 |
| A4 | 가격 오류 | AI는 대략 안내, 최종=견적 엔진(서버) |
| A5 | RAG 유사도 < 0.7 | "사장님께 확인해볼게요!" → T2 알림톡 |

### 주문 플로우

| 코드 | 상황 | 처리 |
|------|------|------|
| B1 | 주문 중 다른 질문 | 답변 후 ordering 상태 복귀 |
| B2 | 메뉴 변경 | collected_data 리셋, 새 메뉴 재시작 |
| B3 | 확정 후 취소 | 입금 전: 자동 취소 / 입금 후: complex → 사장님 |
| B4 | 수량 2+ | order_items.quantity 처리 |
| B5 | 견적 엔진 실패 | "사장님께 확인" → T2 |

### 사장님 관련

| 코드 | 상황 | 처리 |
|------|------|------|
| C1 | complex 장기 미응답 | 30분 재알림 → 1시간 알림톡 → 3시간 직접연락 안내 |
| C2 | 주문 미확정 | 2시간 재알림 → 4시간 알림톡 → 24시간 고객 안내 |
| C3 | 가격 수정 | 사유 필수 → T6 고객 알림톡 |
| C4 | 서비스 정지+고객 접속 | "상담 일시 중지" + 직접 연락처 |
| C5 | 메뉴 변경 | 진행 중 주문: 기존 가격 유지 (order_items 스냅샷) |

### 고객 관련

| 코드 | 상황 | 처리 |
|------|------|------|
| D1 | 주문 중 이탈 | 30분 리마인드 → 24시간 종료(데이터 보존) → 7일 삭제 |
| D2 | 미입금 | 24시간: 대시보드 표시만 / 48시간: 사장님 유지/취소 선택 |
| D3 | 욕설 | 정상 유도 → 3회 시 해당 세션 비활성화 |
| D4 | 사람 연결 요청 | "사장님께 바로 전달" → T2 |
| D5 | 재방문 | 24시간내: 이어서 / 초과: 새 대화 (이전 스크롤업) |

### 시스템

| 코드 | 상황 | 처리 |
|------|------|------|
| E1 | Supabase 다운 | 점검 페이지 + 슬랙 알림 |
| E2 | 알림톡 실패 | 3회 재시도(1분 간격) → 로그 + 수동 재발송 |
| E3 | 이미지 업로드 실패 | 재시도 2회 → "이미지 없이 진행?" |
| E4 | Vercel 타임아웃 | AI 5초+DB 3초 제한, 비동기→Realtime 전달 |

### 결제

| 코드 | 상황 | 처리 |
|------|------|------|
| F1 | 빌링키 발급 실패 | "다른 카드" → 3회 시 고객센터 |
| F2 | 자동결제 실패 | T10 → D+1 재시도 → D+2 재시도 → D+3 정지+T11 |
| F3 | 중복 결제 | idempotency key + unique 제약 → 자동 환불 |
| F4 | 환불 | 해지 시 잔여 기간 사용, 환불 없음 (약관) |

---

## 10. 구독 결제 플로우

### 무료 체험 → 유료 전환

```
가입 → 14일 무료 체험 (카드 등록 없이)
  D+7:  알림톡 T3 "7일 남았어요"
  D+12: 알림톡 T4 "2일 남았어요"
  D+14: 체험 만료
    ├─ 카드 등록됨 → 자동 결제 → Pro → T14 환영
    └─ 카드 미등록 → 서비스 정지 → T12 만료
         → 로그인 시 결제 화면 유도
         → 결제 완료 → 즉시 복구
```

### 월간 자동 결제

```
결제일 → 토스페이먼츠 빌링키 자동 청구
  ├─ 성공 → T13 결제 완료 → 다음 달 계속
  └─ 실패 → T10 결제 실패 → 3일 Grace Period
       D+1 재시도 → D+2 재시도
       ├─ 성공 → 계속
       └─ 실패 → 서비스 정지 + T11
```

---

## 11. 주문 상태 흐름

```
pending (접수)
  → confirmed (사장님 확정) → T5 고객 알림톡
  → cancelled (거절) → T9 고객 알림톡

confirmed → payment_waiting (입금 대기)

payment_waiting → paid (입금 확인) → T7 고객 알림톡

paid → in_progress (제작 중)

in_progress → completed (완료) → T8 고객 알림톡

어느 단계에서든 → cancelled (취소)
```

---

> **프로덕트 기획서 끝** | 오대리 v1.0 | 2026-02-07
